**计算机基础**
    bit就是位，也叫比特位，是计算机表示数据最小的单位

    byte就是字节

    3.1byte=8bit

    4.1byte就是1B

    5.一个字符=2字节

    6.1KB=1024B

   1.**字节就是Byte，也是B**

   2.**位就是bit也是b**

   3.转换关系如下：1)1KB=1024B

   2) 1B= 8b
————————————————

# 连续分配管理方式
## 动态分区分配算法
**用于研究当很多个空闲分区都能满足需求时，应该选择哪个分区分配的问题。其实这个问题需要参照的动态分区分配算法，共有如下四种**
-   首次适应算法(First Fit)
-   最佳适应算法(Best Fit)
-   最坏适应算法(Worst Fit)
## 作业
![[Pasted image 20221201204822.png]]

# 非连续分配管理方式之基本分页存储管理
## 前置知识
<u>页框</u>：在计算机组成原理中我们说过，内存是按照**块**进行管理的，每个块的编号称之为**块号**。而在操作系统中需要换一种说法，称其为**页框（页帧\内存块）**，每个页框有一个编号，叫做**页框号**，页框号从0开始
<u>页</u>：对于用户进程，以**页框为单位**进行划分，称其为**页（页面）**，每个页面也有一个编号，称其为**页号**，页号从0开始
### 页框和页关系
操作系统以**页框为单位为各个进程**分配内存空间，进程的**每个页面分别放入一个页框中**，也即它们是**一一对应的关系**。各个页面不必连续存放，也不必遵循先后顺序，可以放到不相邻的各个页框中
**动态重定位思想**：模块在内存中的**起始地址**+目标内存单元相对于起始位置的**偏移量**

**分页地址转换：可以把进程中<u>所有的页看作一个个连续存放的模块</u>，当页面分配到页框中后，虽然页面彼此之间是分散的，但是每个页面之内却是连续的。因此如果知道一个模块（一个页）的起始地址，并且<u>知道某逻辑地址相对于该起始地址的偏移量，那么物理地址自然很容易得到</u>。关键分为以下几步**

-   要算出逻辑地址对应的**页号**
-   要算出某逻辑地址**在页面内的偏移量**
-   要知道该页号**对应页面在内存中的起始地址**
-   **物理地址=页面的起始地址+偏移量**

# 非连续分配管理方式之基本分段管理方式
## 段表

**段表：为了能获得每个段在内存中存放的位置，操作系统会为每个进程建立一张段映射表，简称为段表。具体来说：**

-   **一个进程对应一张段表**
-   **进程的每一段对应一个段表项**
-   **每个段表项由段号、段长和基址组成**
-   **段表记录了每个段在内存中的起始位置和长度**

![在这里插入图片描述](https://img-blog.csdnimg.cn/966000a06386463d991a90240896f1b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)

**注意：每个段表项长度相同，因此段号和页号一样可以隐含，不占存储空间**

-   比如，某系统按字节寻址，采用分段管理，假设逻辑地址中段号为16位，段内地址为16位，所以16位即可表示最大段长，物理内存为4GB(32位)，因此让每个段表项占用16+32=48位，也即6B（**前2个字节为段长，后4个字节为基址**）。此时**若存放的起始地址为M，则K号段对应段表项物理地址为M+K×6**