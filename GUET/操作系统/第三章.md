**计算机基础**
    bit就是位，也叫比特位，是计算机表示数据最小的单位

    byte就是字节

    3.1byte=8bit

    4.1byte就是1B

    5.一个字符=2字节

    6.1KB=1024B

   1.**字节就是Byte，也是B**

   2.**位就是bit也是b**

   3.转换关系如下：1)1KB=1024B

   2) 1B= 8b
————————————————

# 连续分配管理方式
## 动态分区分配算法
**用于研究当很多个空闲分区都能满足需求时，应该选择哪个分区分配的问题。其实这个问题需要参照的动态分区分配算法，共有如下四种**
-   首次适应算法(First Fit)
-   最佳适应算法(Best Fit)
-   最坏适应算法(Worst Fit)
## 作业
![[Pasted image 20221201204822.png]]

# 非连续分配管理方式之基本分页存储管理
## 前置知识
<u>页框</u>：在计算机组成原理中我们说过，内存是按照**块**进行管理的，每个块的编号称之为**块号**。而在操作系统中需要换一种说法，称其为**页框（页帧\内存块）**，每个页框有一个编号，叫做**页框号**，页框号从0开始
<u>页</u>：对于用户进程，以**页框为单位**进行划分，称其为**页（页面）**，每个页面也有一个编号，称其为**页号**，页号从0开始
### 页框和页关系
操作系统以**页框为单位为各个进程**分配内存空间，进程的**每个页面分别放入一个页框中**，也即它们是**一一对应的关系**。各个页面不必连续存放，也不必遵循先后顺序，可以放到不相邻的各个页框中
**动态重定位思想**：模块在内存中的**起始地址**+目标内存单元相对于起始位置的**偏移量**

**分页地址转换：可以把进程中<u>所有的页看作一个个连续存放的模块</u>，当页面分配到页框中后，虽然页面彼此之间是分散的，但是每个页面之内却是连续的。因此如果知道一个模块（一个页）的起始地址，并且<u>知道某逻辑地址相对于该起始地址的偏移量，那么物理地址自然很容易得到</u>。关键分为以下几步**

-   要算出逻辑地址对应的**页号**
-   要算出某逻辑地址**在页面内的偏移量**
-   要知道该页号**对应页面在内存中的起始地址**
-   **物理地址=页面的起始地址+偏移量**

### 换句话说
**逻辑地址：是程序编译后，生成的目标模块进行编址时都是从0号单元开始编址，称之为目标模块的相对地址，即为逻辑地址。

**<u>页</u>：将进程划分的块，对应的大小就叫页面大小。**

**<u>页框</u>：将内存划分的块。**

**<u>页和页框二者一一对应</u>，一个页放入一个页框，（理论上）页的大小和页框的大小相等。**

**<u>页表</u>：就是一个页和页框一一对应的关系表。【存放在内存中】 关系表只是起到一个索引的作用，说白了就是能根据关系表能查到某一个页面和哪一个页框所对应。**

![[Pasted image 20221201222043.png]]

# 非连续分配管理方式之基本分段管理方式
## 段表

**段表：为了能获得每个段在内存中存放的位置，操作系统会为每个进程建立一张段映射表，简称为段表。具体来说：**

-   **一个进程对应一张段表**
-   **进程的每一段对应一个段表项**
-   **每个段表项由段号、段长和基址组成**
-   **段表记录了每个段在内存中的起始位置和长度**

![在这里插入图片描述](https://img-blog.csdnimg.cn/966000a06386463d991a90240896f1b4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)

**注意：每个段表项长度相同，因此段号和页号一样可以隐含，不占存储空间**

-   比如，某系统按字节寻址，采用分段管理，假设逻辑地址中段号为16位，段内地址为16位，所以16位即可表示最大段长，物理内存为4GB(32位)，因此让每个段表项占用16+32=48位，也即6B（**前2个字节为段长，后4个字节为基址**）。此时**若存放的起始地址为M，则K号段对应段表项物理地址为M+K×6**

# 虚拟内存之置换算法
## **<u>最佳置换算法(OPT</u>，Optimal)：
（既往前看，又往后看）
每次淘汰的页面<u>将是以后永不使用的，或者是在最长时间内不再被访问的页面</u>，这样可以保证最低的缺页率**
- 如下，假设系统为某个进程分配了三个内存块，然后会依次访问某些页面，顺序为：7 77-0 00-1 11-2 22-0 00-3 33-0 00-4 44-2 22-3 33-0 00-3 33-2 22-1 11-2 22-0 00-1 11-7 77-0 00-1 11。其置换过程大致如下

![在这里插入图片描述](https://img-blog.csdnimg.cn/57f0d5b7149c4732b99b0e98c8393ecd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)
## 先进先出置换算法(FIFO)：
每次淘汰的页面是最早进入内存的页面。具体来说，可以把调入内存的页面根据调入先后顺序**排成一个队列，需要换出页面时选择队头即可**，队列的最大长度取决于系统为进程分配了多少个内存块
## 近期最少用置换算法(LRU)
**（只往后看）**
**每次淘汰的页面是<u>最近最久未使用的页面</u>。具体来说，在每个页面对应的页表项中，用访问字段<u>记录该页面自上次被访问以来所经历的时间t</u>，需要淘汰页面时，选择<u>t值最大的那个页面</u>。大致流程如下**

![在这里插入图片描述](https://img-blog.csdnimg.cn/ffd7eadfef9b4b11be5ab0704968aea0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5b-r5LmQ5rGf5rmW,size_20,color_FFFFFF,t_70,g_se,x_16)